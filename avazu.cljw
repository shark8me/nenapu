;; gorilla-repl.fileformat = 1

;; **
;;; # Avazu.
;;; 
;;; Load the avazu dataset in chunks and train a classifier on it.
;; **

;; @@
(ns energized-mist2
  (:require [gorilla-plot.core :as plot]
            [incanter.core :as inc]
            [incanter.io :as incio]
            [incanter.datasets :as incds]
            [clj-ml.data :as cd]
            [clj-ml.classifiers :as cls]
            [clj-ml.utils :as ut]
            [clojure.core.reducers :as r]
            [iota :as iota])
(:import 
           (weka.core Instance Instances)
           (weka.classifiers.meta  RotationForest)))

;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-nil'>nil</span>","value":"nil"}
;; <=

;; @@
(def fpath "/media/kiran/5A76869F76867B8F/datasets/avazu_click_thru_rate_prediction/train_100.csv")
(def fpath100k "/media/kiran/5A76869F76867B8F/datasets/avazu_click_thru_rate_prediction/train100k.csv")
(def fpath300k "/media/kiran/5A76869F76867B8F/datasets/avazu_click_thru_rate_prediction/train300k.csv")
(def fpath1m "/media/kiran/5A76869F76867B8F/datasets/avazu_click_thru_rate_prediction/train1m.csv")
(def fpathfull "/media/kiran/5A76869F76867B8F/datasets/avazu_click_thru_rate_prediction/train.csv")

;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-var'>#&#x27;energized-mist2/fpathfull</span>","value":"#'energized-mist2/fpathfull"}
;; <=

;; @@
(def cols [ "id","click","hour","C1","banner_pos","site_id","site_domain","site_category","app_id","app_domain","app_category","device_id","device_ip","device_model","device_type","device_conn_type","C14","C15","C16","C17","C18","C19","C20","C21"])

;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-var'>#&#x27;energized-mist2/cols</span>","value":"#'energized-mist2/cols"}
;; <=

;; @@
(count cols)
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-unkown'>24</span>","value":"24"}
;; <=

;; @@
(defn parseline 
       [inp]
  (let [k (vec inp)]
        (concat ;[(k 0)] removed id column
          [(keyword (k 1))]
		(for [i (subvec k 2 5)] (Integer/parseInt i))
		(for [i (subvec k 5 14)] (keyword i)) ;removed the last 2 integer columns
		(for [i (subvec k 14)] (Integer/parseInt i)) 
	)))
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-var'>#&#x27;energized-mist2/parseline</span>","value":"#'energized-mist2/parseline"}
;; <=

;; **
;;; Creates a set of the categorical column values. There are 8 categorical columns here, 5-13 . Lets find the number of uniques in 9 columns, from 5 to 13. This will be used to define the dataset, since each of these are categorical columns, and the values need to be predefined.
;; **

;; @@
(def numcat 9)

(defn redfn 
  ([] (vec (repeat numcat #{})))
  ([acc lst]
   (do
     ;(println acc " " lst)
   (mapv #(conj %1 %2) acc lst))))

(defn mergefn 
  ([] (vec (repeat numcat #{})))
  ([a b] (mapv #(into %1 %2) a b)))


(defn getset 
  []
(->> (iota/seq fpath1m)
     rest
     ;(take 10)
    (r/map (fn[x] (clojure.string/split x #",")))
     (r/map (comp vec parseline))
     (r/map (fn[x] (subvec x 4 (+ 4 numcat))))
 	 (r/fold mergefn redfn)    
     ;r/foldcat
     ;(take 2)
    ))

;(def setmaps (mapv getset bcols))./weka/src/main/java/weka/classifiers/trees/DecisionStump.java
(try
(def catcols (getset))
  (catch Exception e
    (clojure.stacktrace/print-stack-trace e)))
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-var'>#&#x27;energized-mist2/catcols</span>","value":"#'energized-mist2/catcols"}
;; <=

;; @@
(mapv count catcols)
;; @@
;; =>
;;; {"type":"list-like","open":"<span class='clj-vector'>[</span>","close":"<span class='clj-vector'>]</span>","separator":" ","items":[{"type":"html","content":"<span class='clj-unkown'>2075</span>","value":"2075"},{"type":"html","content":"<span class='clj-unkown'>2030</span>","value":"2030"},{"type":"html","content":"<span class='clj-unkown'>21</span>","value":"21"},{"type":"html","content":"<span class='clj-unkown'>2309</span>","value":"2309"},{"type":"html","content":"<span class='clj-unkown'>156</span>","value":"156"},{"type":"html","content":"<span class='clj-unkown'>23</span>","value":"23"},{"type":"html","content":"<span class='clj-unkown'>83430</span>","value":"83430"},{"type":"html","content":"<span class='clj-unkown'>313001</span>","value":"313001"},{"type":"html","content":"<span class='clj-unkown'>4581</span>","value":"4581"}],"value":"[2075 2030 21 2309 156 23 83430 313001 4581]"}
;; <=

;; @@
(defn gc [catcols cid]
	(mapv keyword (catcols cid)))

(defn gc1 [cid] (gc catcols cid))

(def kcols 
  [;{:id nil} removed id col
   {:click [:0 :1]} :hour :C1 :banner_pos {:site_id (gc1 0)} {:site_domain (gc1 1)} {:site_category (gc1 2)} {:app_id (gc1 3)} {:app_domain (gc1 4)} {:app_category (gc1 5)} 
   ; {:device_id (gc1 6)} {:device_ip (gc1 7)} 
   {:device_model (gc1 8)} :device_type :device_conn_type :C14 :C15 :C16 :C17 :C18 :C19 :C20 :C21])
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-var'>#&#x27;energized-mist2/kcols</span>","value":"#'energized-mist2/kcols"}
;; <=

;; **
;;; For 1 million instance, the unique counts for the category columns are [2075 2030 21 2309 156 23 83430 313001 4581]. Loading the large number of unique counts into the header field of the dataset throws outofmemory errors. Therefore we'll drop the columns with a large number of uniques (7,8)
;; **

;; @@
(defn parseline2 
       [inp]
  (let [k (vec inp)]
        (concat ;[(k 0)] removed id column
          [(keyword (k 1))]
		(for [i (subvec k 2 5)] (Integer/parseInt i))
		(for [i (subvec k 5 11)] (keyword i))
          ;removed the last 7,8 integer columns
          [(keyword (k 13))] ;add the last categorical column
		(for [i (subvec k 14)] (Integer/parseInt i)) 
	)))
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-var'>#&#x27;energized-mist2/parseline2</span>","value":"#'energized-mist2/parseline2"}
;; <=

;; @@
(def ids 
  (-> 
  	(cd/make-dataset "i2" kcols 0)
    (cd/dataset-set-class 0)
    ))
  ;(catch Exception e
  ;  (println (.getMessage e))))
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-var'>#&#x27;energized-mist2/ids</span>","value":"#'energized-mist2/ids"}
;; <=

;; **
;;; Lets load the avazu data and create an Instance object for each line. We need to previously create the dataset, with 0 instances.
;; **

;; @@
(defn add-inst [ds instlist]
  (reduce #(cd/dataset-add %1 %2) ds instlist)) 

;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-var'>#&#x27;energized-mist2/add-inst</span>","value":"#'energized-mist2/add-inst"}
;; <=

;; @@
(def sds
  (add-inst ids
(->> (iota/subvec (iota/vec fpath300k) 1 10000)
    (mapv (fn[x] (clojure.string/split x #",")))
    (map parseline2)
    (map #(cd/make-instance ids %))    
     ;(take 2)
     ;(map count)
    )
))
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-var'>#&#x27;energized-mist2/sds</span>","value":"#'energized-mist2/sds"}
;; <=

;; @@
(class sds)
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-class'>weka.core.Instances</span>","value":"weka.core.Instances"}
;; <=

;; **
;;; 
;; **

;; @@
(mapv count catcols)
;; @@
;; =>
;;; {"type":"list-like","open":"<span class='clj-vector'>[</span>","close":"<span class='clj-vector'>]</span>","separator":" ","items":[{"type":"html","content":"<span class='clj-unkown'>4737</span>","value":"4737"},{"type":"html","content":"<span class='clj-unkown'>7745</span>","value":"7745"},{"type":"html","content":"<span class='clj-unkown'>26</span>","value":"26"},{"type":"html","content":"<span class='clj-unkown'>8552</span>","value":"8552"},{"type":"html","content":"<span class='clj-unkown'>559</span>","value":"559"},{"type":"html","content":"<span class='clj-unkown'>36</span>","value":"36"},{"type":"html","content":"<span class='clj-unkown'>2686408</span>","value":"2686408"},{"type":"html","content":"<span class='clj-unkown'>6729486</span>","value":"6729486"}],"value":"[4737 7745 26 8552 559 36 2686408 6729486]"}
;; <=

;; @@
(try 
  (def classifier (cls/make-classifier :meta :raced-incremental-logit-boost {:size-of-validation-set 2000 :name-of-base-classifier "weka.classifiers.trees.DecisionStump" } ))                                                                             
  (catch Exception e
    (clojure.stacktrace/print-stack-trace e)))

;(.getValidationChunkSize classifier)
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-var'>#&#x27;energized-mist2/classifier</span>","value":"#'energized-mist2/classifier"}
;; <=

;; @@
(try
(cls/classifier-train classifier sds)
  (catch Exception e
    (clojure.stacktrace/print-stack-trace e)))
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-unkown'>#&lt;RacedIncrementalLogitBoost RacedIncrementalLogitBoost: Best committee on validation data\nBase classifiers: \n\nModel 1\n\tClass 1 (click=0)\n\nDecision Stump\n\nClassifications\n\nC21 &lt;= 39.5 : 0.5217391304347826\nC21 &gt; 39.5 : 1.411764705882353\nC21 is missing : 1.248\n\n\n\tClass 2 (click=1)\n\nDecision Stump\n\nClassifications\n\nC21 &lt;= 39.5 : -0.5217391304347826\nC21 &gt; 39.5 : -1.411764705882353\nC21 is missing : -1.248\n\n\nModel 2\n\tClass 1 (click=0)\n\nDecision Stump\n\nClassifications\n\nC21 &lt;= 14.0 : -2.6849554603609898\nC21 &gt; 14.0 : 0.35090306054495735\nC21 is missing : 0.318336560734559\n\n\n\tClass 2 (click=1)\n\nDecision Stump\n\nClassifications\n\nC21 &lt;= 14.0 : 2.68495546036099\nC21 &gt; 14.0 : -0.35090306054495735\nC21 is missing : -0.318336560734559\n\n\nModel 3\n\tClass 1 (click=0)\n\nDecision Stump\n\nClassifications\n\nC17 &lt;= 1761.0 : -0.6553520813503841\nC17 &gt; 1761.0 : 0.2497589799090006\nC17 is missing : -0.12278900046890907\n\n\n\tClass 2 (click=1)\n\nDecision Stump\n\nClassifications\n\nC17 &lt;= 1761.0 : 0.6553520813503781\nC17 &gt; 1761.0 : -0.24975897990899892\nC17 is missing : 0.12278900046890856\n\n\nModel 4\n\tClass 1 (click=0)\n\nDecision Stump\n\nClassifications\n\nsite_id = 93eaba74 : -4.0\nsite_id != 93eaba74 : 0.3055881421817336\nsite_id is missing : 0.25389050533933566\n\n\n\tClass 2 (click=1)\n\nDecision Stump\n\nClassifications\n\nsite_id = 93eaba74 : 4.0\nsite_id != 93eaba74 : -0.3055881421817337\nsite_id is missing : -0.25389050533933594\n\nNumber of models: 4\nChunk size per model: 500\n&gt;</span>","value":"#<RacedIncrementalLogitBoost RacedIncrementalLogitBoost: Best committee on validation data\nBase classifiers: \n\nModel 1\n\tClass 1 (click=0)\n\nDecision Stump\n\nClassifications\n\nC21 <= 39.5 : 0.5217391304347826\nC21 > 39.5 : 1.411764705882353\nC21 is missing : 1.248\n\n\n\tClass 2 (click=1)\n\nDecision Stump\n\nClassifications\n\nC21 <= 39.5 : -0.5217391304347826\nC21 > 39.5 : -1.411764705882353\nC21 is missing : -1.248\n\n\nModel 2\n\tClass 1 (click=0)\n\nDecision Stump\n\nClassifications\n\nC21 <= 14.0 : -2.6849554603609898\nC21 > 14.0 : 0.35090306054495735\nC21 is missing : 0.318336560734559\n\n\n\tClass 2 (click=1)\n\nDecision Stump\n\nClassifications\n\nC21 <= 14.0 : 2.68495546036099\nC21 > 14.0 : -0.35090306054495735\nC21 is missing : -0.318336560734559\n\n\nModel 3\n\tClass 1 (click=0)\n\nDecision Stump\n\nClassifications\n\nC17 <= 1761.0 : -0.6553520813503841\nC17 > 1761.0 : 0.2497589799090006\nC17 is missing : -0.12278900046890907\n\n\n\tClass 2 (click=1)\n\nDecision Stump\n\nClassifications\n\nC17 <= 1761.0 : 0.6553520813503781\nC17 > 1761.0 : -0.24975897990899892\nC17 is missing : 0.12278900046890856\n\n\nModel 4\n\tClass 1 (click=0)\n\nDecision Stump\n\nClassifications\n\nsite_id = 93eaba74 : -4.0\nsite_id != 93eaba74 : 0.3055881421817336\nsite_id is missing : 0.25389050533933566\n\n\n\tClass 2 (click=1)\n\nDecision Stump\n\nClassifications\n\nsite_id = 93eaba74 : 4.0\nsite_id != 93eaba74 : -0.3055881421817337\nsite_id is missing : -0.25389050533933594\n\nNumber of models: 4\nChunk size per model: 500\n>"}
;; <=

;; @@
(def evaluation (cls/classifier-evaluate classifier :cross-validation sds 10))
(println (:summary evaluation))
;; @@
;; ->
;;; 
;;; Correctly Classified Instances       82330               82.2494 %
;;; Incorrectly Classified Instances     17768               17.7506 %
;;; Kappa statistic                          0.0986
;;; Mean absolute error                      0.2651
;;; Root mean squared error                  0.3692
;;; Relative absolute error                 91.8308 %
;;; Root relative squared error             97.1854 %
;;; Total Number of Instances           100098     
;;; 
;;; 
;; <-
;; =>
;;; {"type":"html","content":"<span class='clj-nil'>nil</span>","value":"nil"}
;; <=

;; @@
(defn redfn
  ;([] ids)
  [dset inst]
   ;(do (println "in redfn " (class inst) " cla " (class clsi))
      (cd/dataset-add ids inst))
   ;(cls/classifier-update clsi inst)))
  

(defn mergefn
  ([] classifier)
  ([clsi instances]
   (do (println "in mergefn " (class instances) " cla " (class clsi))
   (cls/classifier-update clsi instances)))
  )

(defn get-instances
  [ids start end]
(try
  (do
    (println "instance count " (.numInstances ids))
(->> (iota/subvec (iota/vec fpath300k) start end)
    (r/map (fn[x] (clojure.string/split x #",")))
    (r/map parseline2)
    (r/map #(cd/make-instance ids %))    
	(r/reduce redfn ids)
     ;(take 2)
     ;(map class)
    ))
  (catch Exception e
    (clojure.stacktrace/print-stack-trace e))))

;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-var'>#&#x27;energized-mist2/get-instances</span>","value":"#'energized-mist2/get-instances"}
;; <=

;; @@
(.numInstances ids)
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-unkown'>13993</span>","value":"13993"}
;; <=

;; @@
cls/classifier-evaluate
;; @@
;; =>
;;; {"type":"list-like","open":"<span class='clj-lazy-seq'>(</span>","close":"<span class='clj-lazy-seq'>)</span>","separator":" ","items":[{"type":"list-like","open":"<span class='clj-lazy-seq'>(</span>","close":"<span class='clj-lazy-seq'>)</span>","separator":" ","items":[{"type":"html","content":"<span class='clj-long'>0</span>","value":"0"},{"type":"html","content":"<span class='clj-long'>5000</span>","value":"5000"}],"value":"(0 5000)"},{"type":"list-like","open":"<span class='clj-lazy-seq'>(</span>","close":"<span class='clj-lazy-seq'>)</span>","separator":" ","items":[{"type":"html","content":"<span class='clj-long'>5000</span>","value":"5000"},{"type":"html","content":"<span class='clj-long'>10000</span>","value":"10000"}],"value":"(5000 10000)"},{"type":"list-like","open":"<span class='clj-lazy-seq'>(</span>","close":"<span class='clj-lazy-seq'>)</span>","separator":" ","items":[{"type":"html","content":"<span class='clj-long'>10000</span>","value":"10000"},{"type":"html","content":"<span class='clj-long'>15000</span>","value":"15000"}],"value":"(10000 15000)"},{"type":"list-like","open":"<span class='clj-lazy-seq'>(</span>","close":"<span class='clj-lazy-seq'>)</span>","separator":" ","items":[{"type":"html","content":"<span class='clj-long'>15000</span>","value":"15000"},{"type":"html","content":"<span class='clj-long'>20000</span>","value":"20000"}],"value":"(15000 20000)"}],"value":"((0 5000) (5000 10000) (10000 15000) (15000 20000))"}
;; <=

;; @@
(defn makefolds
  [sampsize at ]
(mapv (fn[[x y]] (let [v (int (* 0.8 sampsize))
                                q  (+ x v)]
                                [[x q] [q y]])) iseq))
;; @@

;; @@
(let [sampsize 5000
      iseq (partition 2 1 (range sampsize 20001 sampsize))
      is (mapv (fn[[x y]] (let [v (int (* 0.8 sampsize))
                                q  (+ x v)]
                                [[x q] [q y]])) iseq)]
  is)


;; @@
;; =>
;;; {"type":"list-like","open":"<span class='clj-vector'>[</span>","close":"<span class='clj-vector'>]</span>","separator":" ","items":[{"type":"list-like","open":"<span class='clj-vector'>[</span>","close":"<span class='clj-vector'>]</span>","separator":" ","items":[{"type":"list-like","open":"<span class='clj-vector'>[</span>","close":"<span class='clj-vector'>]</span>","separator":" ","items":[{"type":"html","content":"<span class='clj-long'>5000</span>","value":"5000"},{"type":"html","content":"<span class='clj-long'>9000</span>","value":"9000"}],"value":"[5000 9000]"},{"type":"list-like","open":"<span class='clj-vector'>[</span>","close":"<span class='clj-vector'>]</span>","separator":" ","items":[{"type":"html","content":"<span class='clj-long'>9000</span>","value":"9000"},{"type":"html","content":"<span class='clj-long'>10000</span>","value":"10000"}],"value":"[9000 10000]"}],"value":"[[5000 9000] [9000 10000]]"},{"type":"list-like","open":"<span class='clj-vector'>[</span>","close":"<span class='clj-vector'>]</span>","separator":" ","items":[{"type":"list-like","open":"<span class='clj-vector'>[</span>","close":"<span class='clj-vector'>]</span>","separator":" ","items":[{"type":"html","content":"<span class='clj-long'>10000</span>","value":"10000"},{"type":"html","content":"<span class='clj-long'>14000</span>","value":"14000"}],"value":"[10000 14000]"},{"type":"list-like","open":"<span class='clj-vector'>[</span>","close":"<span class='clj-vector'>]</span>","separator":" ","items":[{"type":"html","content":"<span class='clj-long'>14000</span>","value":"14000"},{"type":"html","content":"<span class='clj-long'>15000</span>","value":"15000"}],"value":"[14000 15000]"}],"value":"[[10000 14000] [14000 15000]]"},{"type":"list-like","open":"<span class='clj-vector'>[</span>","close":"<span class='clj-vector'>]</span>","separator":" ","items":[{"type":"list-like","open":"<span class='clj-vector'>[</span>","close":"<span class='clj-vector'>]</span>","separator":" ","items":[{"type":"html","content":"<span class='clj-long'>15000</span>","value":"15000"},{"type":"html","content":"<span class='clj-long'>19000</span>","value":"19000"}],"value":"[15000 19000]"},{"type":"list-like","open":"<span class='clj-vector'>[</span>","close":"<span class='clj-vector'>]</span>","separator":" ","items":[{"type":"html","content":"<span class='clj-long'>19000</span>","value":"19000"},{"type":"html","content":"<span class='clj-long'>20000</span>","value":"20000"}],"value":"[19000 20000]"}],"value":"[[15000 19000] [19000 20000]]"}],"value":"[[[5000 9000] [9000 10000]] [[10000 14000] [14000 15000]] [[15000 19000] [19000 20000]]]"}
;; <=

;; @@
(defn measure 
  [clsa trainset valset]
  (let [[trainpred, valpred] (map #(for [i (cd/dataset-seq %)] 
                                     (int (cls/classifier-classify clsa i))) [trainset valset])
        [trainy,valy] (mapv #(for [i (cd/dataset-class-values %)] (Integer/parseInt i))
                              [trainset valset])
        eqcntfn (fn[x y] ;(/ 
                           (count (filter (fn[[a b]] (= a b)) (mapv vector x y))) 
                                  ;(count y)
                           )]
    (println " train " (eqcntfn trainpred trainy)  "val "(eqcntfn valpred valy)
             " len " (map count [trainpred valpred trainy valy]) 
             " nums " (map #(.numInstances %) [trainset valset]))
        ;(println " train " (map class (map first [trainpred trainy])) 
        ;         " "  (map first [trainpred trainy])
        ;         " " (map keyword (map first [trainpred trainy])))
    )
  )
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-var'>#&#x27;energized-mist2/measure</span>","value":"#'energized-mist2/measure"}
;; <=

;; @@
(try
	(let [eds (-> 
  				(cd/make-dataset "i2" kcols 0)
    			(cd/dataset-set-class 0))
          sampsize 100
      	iseq (partition 2 1 (range sampsize 501 sampsize))
      	is (mapv (fn[[x y]] (let [v (int (* 0.8 sampsize))
                                q  (+ x v)]
                                [[x q] [q y]])) iseq)
        c1 (cls/classifier-train classifier (get-instances eds 1 sampsize))]
      (reduce (fn[cl ks]
                (let [[trainset,valset] 
                      (mapv (fn[[s e]] (get-instances eds s e)) ks)
                      ]
                  (measure cl trainset valset)
      			(cls/classifier-update cl trainset)))
              c1 is)
      nil)
  (catch Exception e
    (clojure.stacktrace/print-stack-trace e)))
;; @@
;; ->
;;; instance count  0
;;; instance count  0
;;; instance count  0
;;;  train  172912 val  172912  len  (209858 209858 209858 209858)  nums  (209858 209858)
;;; instance count  0
;;; instance count  0
;;;  train  172386 val  172386  len  (209958 209958 209958 209958)  nums  (209958 209958)
;;; instance count  0
;;; instance count  0
;;;  train  173157 val  173157  len  (210058 210058 210058 210058)  nums  (210058 210058)
;;; instance count  0
;;; instance count  0
;;;  train  173153 val  173153  len  (210158 210158 210158 210158)  nums  (210158 210158)
;;; 
;; <-
;; =>
;;; {"type":"html","content":"<span class='clj-nil'>nil</span>","value":"nil"}
;; <=

;; @@

;; @@
